function getRequirePaths(dirname) {
    if ("/" === dirname) return [ "/node_modules" ];
    var paths = [];
    var parts = dirname.split("/");
    for (var i = 0, len = parts.length; len > i; i++) {
        var p = parts.slice(0, len - i);
        paths.push(p.join("/") + "/node_modules");
    }
    return paths;
}

function loadAsFile(filepath) {
    var checks = [ filepath, filepath + ".js", filepath + ".json" ];
    for (var i = 0, len = checks.length; len > i; i++) if (getLoadableFile(checks[i])) return checks[i];
}

function loadAsDirectory(filepath) {
    if (!Ti.Filesystem.getFile(appDir, filepath).isDirectory()) return;
    var packageJsonFile = Ti.Filesystem.getFile(appDir, filepath + "/package.json");
    if (packageJsonFile.exists()) {
        var json = JSON.parse(packageJsonFile.read().text);
        if (json.main) return path.resolve(filepath + "/" + json.main);
    }
    var indexFile = Ti.Filesystem.getFile(appDir, filepath + "/index.js");
    if (indexFile.exists()) return filepath + "/index.js";
}

function getLoadableFile(filepath) {
    var file = Ti.Filesystem.getFile(appDir, filepath);
    if (file.exists() && !file.isDirectory()) return file;
}

var appDir = Ti.Filesystem.resourcesDirectory, _require = require, path;

module.exports = function(dirname, _module) {
    var req = function(p) {
        var cached = req.cache[p];
        if (cached) return cached;
        var resolved = req.resolve(p);
        cached = req.cache[resolved];
        if (cached) return cached;
        var loaded;
        if (/\.json$/.test(resolved)) {
            var jsonFile = Ti.Filesystem.getFile(appDir, resolved);
            loaded = JSON.parse(jsonFile.read().text);
        } else {
            loaded = _require(resolved.replace(/\.(?:js|json)$/, ""));
            req.cache[resolved] = req.cache[p] = loaded;
        }
        return loaded;
    };
    req.cache = {};
    req.paths = getRequirePaths(dirname);
    req.main = _require.main;
    req.resolve = function(p) {
        var rawPath, isNodeModule = false;
        if (0 === p.indexOf("/")) rawPath = p; else if (0 === p.indexOf("../") || 0 === p.indexOf("./")) rawPath = dirname + ("/" === dirname ? "" : "/") + p; else {
            isNodeModule = true;
            rawPath = p;
        }
        var modulePath, resolvedPath = path.resolve(rawPath);
        if (isNodeModule) for (var i = 0, len = req.paths.length; len > i; i++) {
            var newResolvedPath = req.paths[i] + resolvedPath;
            modulePath = loadAsFile(newResolvedPath) || loadAsDirectory(newResolvedPath);
            if (modulePath) break;
        } else modulePath = loadAsFile(resolvedPath) || loadAsDirectory(resolvedPath);
        if (!modulePath) {
            var err = new Error("Cannot find module '" + p + "' loaded from '" + _module.filename + "'");
            err.code = "MODULE_NOT_FOUND";
            throw err;
        }
        return modulePath;
    };
    return req;
};

var process = {
    cwd: function() {
        return "/";
    }
};

path = function() {
    function normalizeArray(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if ("." === last) parts.splice(i, 1); else if (".." === last) {
                parts.splice(i, 1);
                up++;
            } else if (up) {
                parts.splice(i, 1);
                up--;
            }
        }
        if (allowAboveRoot) for (;up--; up) parts.unshift("..");
        return parts;
    }
    function filter(xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; xs.length > i; i++) f(xs[i], i, xs) && res.push(xs[i]);
        return res;
    }
    var exports = {};
    exports.resolve = function() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : process.cwd();
            if ("string" != typeof path) throw new TypeError("Arguments to path.resolve must be strings");
            if (!path) continue;
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = "/" === path.charAt(0);
        }
        resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
            return !!p;
        }), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    };
    return exports;
}();